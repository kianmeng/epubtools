<?xml version="1.0" encoding="UTF-8"?>
<schema xmlns="http://purl.oclc.org/dsdl/schematron" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:dbk="http://docbook.org/ns/docbook"
  xmlns:c="http://www.w3.org/ns/xproc-step"
  xmlns:tr="http://transpect.io"
  tr:rule-family="epubtools"
  queryBinding="xslt2">
  
  <ns prefix="opf" uri="http://www.idpf.org/2007/opf"/>
  <ns prefix="c" uri="http://www.w3.org/ns/xproc-step"/>
  <ns prefix="cx" uri="http://xmlcalabash.com/ns/extensions"/>
  <ns prefix="dc" uri="http://purl.org/dc/elements/1.1/"/>
  <ns prefix="epub" uri="http://www.idpf.org/2007/ops"/>
  <ns prefix="html" uri="http://www.w3.org/1999/xhtml"/>
  <ns prefix="xs" uri="http://www.w3.org/2001/XMLSchema"/>
  <ns prefix="tr" uri="http://transpect.io"/>
  <ns prefix="svg" uri="http://www.w3.org/2000/svg"/>
  <ns prefix="xlink" uri="http://www.w3.org/1999/xlink"/>
  <ns prefix="ncx" uri="http://www.daisy.org/z3986/2005/ncx/"/>

  <let name="opf-package" value="/c:wrap/opf:package"/>

  <p>The abstract patterns in this Schematron need to be processed with oXygen’s iso-schematron-abstract.xsl.
  The ISO Schematron distribution’s iso_abstract_expand.xsl will not allow the params in the role attribute of an
  assert or report statement. This means that this Schematron will be processed as expected in oXygen, but not by
  the standard XProc p:validate-with-schematron step included with Calabash. Until Calabash migrates to oXygen’s 
  abstract pattern expansion, tr:oxy-validate-with-schematron from https://github.com/transpect/schematron
  may be used.</p>

  <xsl:include href="http://transpect.io/xslt-util/resolve-uri/xsl/resolve-uri.xsl"/>
  <xsl:include href="http://transpect.io/xslt-util/isbn/xsl/isbncheck.xsl"/>
  <xsl:include href="http://transpect.io/xslt-util/num/xsl/num.xsl"/>
  
  <include href="http://transpect.io/xslt-util/isbn/sch/check-isbn.sch.xml"/>
  
  <let name="oebps-paths" value="/c:wrap/cx:document[@name = 'wrap-file-uris']/c:file/@oebps-name"/>

  <let name="source-dir-uri" value="/c:wrap/html:html[1]/html:head/html:meta[@name = 'source-dir-uri']/@content"/>

  <let name="containers" value="('div', 'section', 'body', 'aside', 'nav', 'footer', 'main')"/>

  <let name="epub-version" value="/c:wrap/opf:package/@version"/>

  <pattern id="one-html-input">
    <rule context="/c:wrap">
      <let name="multiple-html-input" value="/c:wrap/epub-config/checks/check[@param = 'multiple-html-input'][@severity = 'warning']/@value"/>
      <!-- 0 html inputs is permitted for checks of already existing EPUBs (as opposed to EPUBs that have been 
        freshly generated from HTML) -->
      <assert test="count(html:html) le 1" id="unexpected-validation-input1" diagnostics="unexpected-validation-input1_de" role="error">
       <span class="srcpath">BC_orphans</span>
        There is more than one HTML file in the validation input. This is an indication that the splitting failed. You might
      need developer support.</assert>
    </rule>
  </pattern>

  <pattern id="epub-file-size" abstract="true">
    <rule context="c:zipfile">
      <let name="size-in-mb" value="number(@size) * 0.00000095367"/>
      <!-- we need this variable for the diagnostics (the params don’t seem to be in scope there): -->
      <let name="max" value="$result-max-mb"/>
      <report test="$size-in-mb &gt; $max" id="epub-size" diagnostics="epub-size_de" role="$severity">
        <span class="srcpath">BC_orphans</span>
        EPUB file '<value-of select="@href"/>' is quite large: <value-of 
          select="format-number($size-in-mb, '#0.0')"/>&#xa0;MB. Limit: <value-of 
          select="format-number($max, '#0.0')"/>&#xa0;MB
      </report>
    </rule>
  </pattern>
  
  <pattern id="epub-size-error" is-a="epub-file-size">
    <param name="severity" value="error"/>
    <param name="result-max-mb" 
      value="/c:wrap/epub-config/checks/check[@param = 'result-max-mb']
                                             [@severity = 'error' or not(@severity)]/@value"/>
  </pattern>
  
  <pattern id="epub-size-warning" is-a="epub-file-size">
    <param name="severity" value="warning"/>
    <param name="result-max-mb" 
      value="/c:wrap/epub-config/checks/check[@param = 'result-max-mb'][@severity = 'warning']/@value"/>
  </pattern>
  
  <pattern id="broken-raster-images">
    <rule context="opf:item[matches(@media-type, '^image/(jpeg|png)')][c:error]">
      <let name="element-in-split" 
        value="/c:wrap/cx:document[@name = 'wrap-chunks']//html:img[matches(@src, concat('(^|/)', current()/@href, '$'))]"/>
      <let name="srcpath" value="for $s in $element-in-split/ancestor-or-self::*[@srcpath][1]/@srcpath return tokenize($s, '\s+')"/>
      <report test="true()" id="read-image" diagnostics="read-image_de" role="error">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
        Image file '<value-of select="@href"/>' broken or unavailable:
        <value-of select="c:error"/>
      </report>
    </rule>
    <rule context="opf:item[matches(@href, '\.(jpe?g|png)$', 'i')][not(c:error)]">
      <let name="element-in-filelist" 
        value="/c:wrap/cx:document[@name = 'wrap-file-uris']/c:file[@name = current()/@href]"/>
      <let name="element-in-split" 
        value="/c:wrap/cx:document[@name = 'wrap-chunks']//html:img[matches(@src, concat('(^|/)', current()/@href, '$'))]"/>
      <let name="srcpath" value="for $s in $element-in-split/ancestor-or-self::*[@srcpath][1]/@srcpath return tokenize($s, '\s+')"/>
      <assert test="exists($element-in-filelist/c:results)" id="image-analysis-failed" diagnostics="image-analysis-failed_de" role="error">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
        Image file '<value-of select="@href"/>' broken or unavailable.
      </assert>
    </rule>
  </pattern>

  <pattern id="not-found-raster-images">
    <rule context="opf:item[matches(@href, '\.(png|jpe?g)$', 'i')]">
      <let name="regex" value="concat('(^|/)', current()/@href, '$')"/>
      <let name="element-in-split" 
        value="/c:wrap/cx:document[@name = 'wrap-chunks']//(
                                                               html:img[matches(@src, $regex)] 
                                                             | svg:image[matches(@xlink:href, $regex)]
                                                            )"/>
      <let name="srcpath" value="for $s in $element-in-split/ancestor-or-self::*[@srcpath][1]/@srcpath return tokenize($s, '\s+')"/>
      <report test="@media-type = 'text/plain'" id="dummy-image" diagnostics="dummy-image_de" role="error">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
        A 1-byte text replacement has been inserted since <value-of select="@href"/> could not be found at its source path. 
        Missing images (or text formats instead of images) may affect downstream processes such as kindlegen.
      </report>
    </rule>
  </pattern>

  <pattern id="calc">
    <rule abstract="true" id="file-calc">
      <let name="regex" value="concat('(^|/)', current()/@href, '$')"/>
      <let name="element-in-split" 
        value="(/c:wrap/cx:document[@name = 'wrap-chunks']//(
                                                               html:img[matches(@src, $regex)] 
                                                             | svg:image[matches(@xlink:href, $regex)]
                                                            ))[1]"/>
      <let name="srcpath" value="for $s in $element-in-split/ancestor-or-self::*[@srcpath][1]/@srcpath return tokenize($s, '\s+')"/>
      <let name="element-in-filelist" 
        value="/c:wrap/cx:document[@name = 'wrap-file-uris']/c:file[@name = current()/@href]"/>
      <let name="size-in-mb" value="number($element-in-filelist[1]/@size) * 0.00000095367431640625"/>
      <let name="width" value="number(
                                 (for $dim in $element-in-filelist/c:results/c:result[@name = 'width']/@value 
                                 return replace($dim, 'px$', '')[. castable as xs:double])[1]
                               )"/>
      <let name="height" value="number(
                                 (for $dim in $element-in-filelist/c:results/c:result[@name = 'height']/@value 
                                 return replace($dim, 'px$', '')[. castable as xs:double])[1]
                               )"/>
      <let name="dpi" value="number(
                               (
                                 for $dim in $element-in-filelist/c:results/c:result[@name = 'density']/@value 
                                 return replace($dim, 'dpi$', '')[. castable as xs:double],
                                 0
                               )[1]  
                             )"/>
      <let name="size-in-mpx" value="$width * $height * 0.000001"/>
      <let name="colorspace" value="$element-in-filelist/c:results/c:result[@name = 'colorspace']/@value"/>
    </rule>
  </pattern>
  <pattern id="html-file-size" abstract="true">
    <rule context="opf:item[@media-type = 'application/xhtml+xml']">
      <extends rule="file-calc"/>
      <let name="size-in-kb" value="$size-in-mb * 1024"/>
      <let name="max" value="$html-max-kb"/>
      <let name="element-in-split"
        value="/c:wrap/cx:document[@name = 'wrap-chunks']/html:html[ends-with(@xml:base, current()/@href)]/html:body"/>
      <let name="srcpath" value="for $s in ($element-in-split/descendant::*[not(self::*:div)][@srcpath])[1]/@srcpath return tokenize($s, '\s+')"/>
      <report test="$size-in-kb &gt; $html-max-kb" id="large-html-file" 
        diagnostics="large-html-file_de" role="$severity">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
        HTML file '<value-of select="@href"/>' is too large for some reading systems: <value-of 
          select="format-number($size-in-kb, '#0')"/>&#xa0;kB
      	If possible insert some breaking points or decrease the number of characters that are included per file.
      	<br xmlns="http://www.w3.org/1999/xhtml"/>
      	<br xmlns="http://www.w3.org/1999/xhtml"/>
      	To better estimate how long the file is, here is the last text of the file:
      	<br xmlns="http://www.w3.org/1999/xhtml"/>
      	<blockquote xmlns="http://www.w3.org/1999/xhtml">
      		<xsl:value-of select="$element-in-split/(descendant-or-self::*[self::html:p][normalize-space()])[last()]"/>
      	</blockquote>
      </report>
    </rule>
  </pattern>
  
  <!--
    Including a file twice is totally acceptable. We should occasionally make sure that the file list will be 
    made unique.
    <pattern id="ambiguous_images">
    <rule context="opf:item">
      <extends rule="file-calc"/>
      <report test="count($element-in-filelist) gt 1" role="error">More than one opf item appears in the list of 
      processed files. <xsl:sequence select="$element-in-filelist"/></report>
    </rule>
  </pattern>-->
  
  <pattern id="html-file-size-warnings" is-a="html-file-size">
    <param name="severity" value="warning"/>
    <param name="html-max-kb" 
      value="/c:wrap/epub-config/checks/check[@param = 'html-max-kb'][@severity = 'warning']/@value"/>
  </pattern>
  
  <pattern id="html-file-size-errors" is-a="html-file-size">
    <param name="severity" value="error"/>
    <param name="html-max-kb" 
      value="/c:wrap/epub-config/checks/check[@param = 'html-max-kb']
                                              [@severity = 'error' or empty(@severity)]/@value"/>
  </pattern>
  
  
  <!-- Caution: the opf:scheme attribute is not allowed in EPUB3.0, if you want to check the ISBN for this
  version you have to activate it using <check param="isbn-checks" value="true"/> in your config file -->
   <pattern id="isbn-checks">
    <rule context="/c:wrap/epub-config/metadata">
      <let name="active" value="/c:wrap/epub-config/checks/check[@param = 'isbn-checks']/@value"/>
      <let name="isbn" value="replace(
                                      replace(if ($epub-version ne '3.0') 
                                                then dc:identifier[@opf:scheme='ISBN']
                                                else dc:identifier[1], 
                                       '-',
                                       ''),
                                       '\s?(Leseprobe|sample)',
                                       '')"/>
      <extends rule="isbn-check-abstract-rule"/>
    </rule>
   </pattern>
  

  <pattern id="cover-image" abstract="true">
    <rule context="opf:item[matches(@media-type, '^image/(jpeg|png)')]
                           [@id = ../parent::opf:package[@version = '2.0']/opf:metadata/opf:meta[@name = 'cover']/@content
                            or (ancestor::opf:package/@version = '3.0' and tokenize(@properties, '\s+') = 'cover-image')]">
      <extends rule="file-calc"/>
      <!-- we need these variables for the diagnostics (the params don’t seem to be in scope there): -->
      <let name="min" value="$cover-min-width-px"/>
      <let name="max" value="$cover-max-width-px"/>
      <report test="$width &lt; $min" id="cover-too-narrow" diagnostics="cover-too-narrow_de" role="$severity">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
        The cover '<value-of select="@href"/>' is too narrow: <value-of 
          select="format-number($width, '#0')"/>&#xa0;px. Minimum is <value-of select="$min"/>.
      </report>
      <report test="$width &gt; $max" id="cover-too-wide" diagnostics="cover-too-wide_de" role="$severity">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
        The cover '<value-of select="@href"/>' is too wide: <value-of 
          select="format-number($width, '#0')"/>&#xa0;px. Maximum is <value-of select="$max"/>.
      </report>
    </rule>
  </pattern>
  
  <pattern id="cover-image-warnings" is-a="cover-image">
    <param name="severity" value="warning"/>
    <param name="cover-max-width-px" 
      value="/c:wrap/epub-config/checks/check[@param = 'cover-max-width-px'][@severity = 'warning']/@value"/>
    <param name="cover-min-width-px" 
      value="/c:wrap/epub-config/checks/check[@param = 'cover-min-width-px'][@severity = 'warning']/@value"/>
  </pattern>

  <pattern id="cover-image-errors" is-a="cover-image">
    <param name="severity" value="error"/>
    <param name="cover-max-width-px" 
      value="/c:wrap/epub-config/checks/check[@param = 'cover-max-width-px']
                                             [@severity = 'error' or empty(@severity)]/@value"/>
    <param name="cover-min-width-px" 
      value="/c:wrap/epub-config/checks/check[@param = 'cover-min-width-px']
                                              [@severity = 'error' or empty(@severity)]/@value"/>
  </pattern>
  
  <pattern id="pixel-size" abstract="true">
    <rule context="opf:item[matches(@media-type, '^image/(jpeg|png|gif)')]
                           [/c:wrap/cx:document[@name = 'wrap-file-uris']/c:file[@name = current()/@href]/c:results]">
      <extends rule="file-calc"/>
      <!-- we need these variables for the diagnostics (the params don’t seem to be in scope there): -->
      <let name="max" value="$image-max-mpx"/>
      <let name="max-mb" value="$image-max-mb"/>
      <report test="$size-in-mpx &gt; $image-max-mpx" id="large-image" diagnostics="large-image_de" role="$severity">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
        Image '<value-of select="@href"/>' is quite large: <value-of select="$width"/>×<value-of select="$height"/> 
        (<value-of select="format-number($size-in-mpx, '#0.00')"/>&#xa0;Mpx). The threshold is <value-of 
          select="$max"/>. <xsl:if 
          test="$size-in-mb &lt;= $max-mb"> The file size (<xsl:value-of 
            select="format-number($size-in-mb, '#0.00')"/> MB) is still ok though. </xsl:if>
      </report>
    </rule>
  </pattern>
  
  <pattern id="pixel-size-warnings" is-a="pixel-size">
    <param name="severity" value="warning"/>
    <param name="image-max-mpx" 
      value="/c:wrap/epub-config/checks/check[@param = 'image-max-mpx'][@severity = 'warning']/@value"/>
    <param name="image-max-mb" 
      value="/c:wrap/epub-config/checks/check[@param = 'image-max-mb'][@severity = 'warning']/@value"/>
  </pattern>
  
  <pattern id="pixel-size-errors" is-a="pixel-size">
    <param name="severity" value="error"/>
    <param name="image-max-mpx" 
      value="/c:wrap/epub-config/checks/check[@param = 'image-max-mpx']
                                             [@severity = 'error' or empty(@severity)]/@value"/>
    <param name="image-max-mb" 
      value="/c:wrap/epub-config/checks/check[@param = 'image-max-mb']
                                              [@severity = 'error' or empty(@severity)]/@value"/>
  </pattern>
  
  <pattern id="image-dims" abstract="true">
    <rule context="opf:item[matches(@media-type, '^image/(jpeg|png|gif)')]
                           [/c:wrap/cx:document[@name = 'wrap-file-uris']/c:file[@name = current()/@href]/c:results]
                           [not( (: cover will be treated separately :)
                              @id = ../parent::opf:package[@version = '2.0']/opf:metadata/opf:meta[@name = 'cover']/@content
                              or (ancestor::opf:package/@version = '3.0' and tokenize(@properties, '\s+') = 'cover-image')
                           )]">
      <extends rule="file-calc"/>
      <!-- we need these variables for the diagnostics (the params don’t seem to be in scope there): -->
      <let name="_threshold" value="$threshold"/>
      <let name="_min-or-max" value="$min-or-max"/>
      <let name="_width-or-height" value="$width-or-height"/>
      <let name="actual-dim" value="if ($_width-or-height = 'height') 
                                    then $height 
                                    else
                                      if ($_width-or-height = 'width')
                                      then $width
                                      else ()"/>
      <report test="if ($_min-or-max = 'max')
                    then $actual-dim &gt; $_threshold
                    else
                      if ($_min-or-max = 'min')
                      then $actual-dim &lt; $_threshold
                      else false()" id="image-dimensions" role="$severity" diagnostics="image-dimensions_de">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
        Pixel <value-of select="$_width-or-height"/> of image '<value-of select="@href"/>' too <value-of 
          select="if ($_min-or-max = 'min') then 'small' else 'large'"/>. Value: <value-of select="$actual-dim"/>. Threshold: <value-of 
          select="$_threshold"/>.
      </report>
    </rule>
  </pattern>
  
  <pattern id="image-too-wide-error" is-a="image-dims">
    <param name="severity" value="error"/>
    <param name="width-or-height" value="'width'"/>
    <param name="min-or-max" value="'max'"/>
    <param name="threshold" 
      value="/c:wrap/epub-config/checks/check[@param = 'image-max-width']
                                             [@severity = 'error' or empty(@severity)]/@value"/>
  </pattern>
  
  <pattern id="image-too-wide-warning" is-a="image-dims">
    <param name="severity" value="warning"/>
    <param name="width-or-height" value="'width'"/>
    <param name="min-or-max" value="'max'"/>
    <param name="threshold" 
      value="/c:wrap/epub-config/checks/check[@param = 'image-max-width']
                                             [@severity = 'warning']/@value"/>
  </pattern>
  
  <pattern id="image-too-narrow-error" is-a="image-dims">
    <param name="severity" value="error"/>
    <param name="width-or-height" value="'width'"/>
    <param name="min-or-max" value="'min'"/>
    <param name="threshold" 
      value="/c:wrap/epub-config/checks/check[@param = 'image-min-width']
                                             [@severity = 'error' or empty(@severity)]/@value"/>
  </pattern>
  
  <pattern id="image-too-narrow-warning" is-a="image-dims">
    <param name="severity" value="warning"/>
    <param name="width-or-height" value="'width'"/>
    <param name="min-or-max" value="'min'"/>
    <param name="threshold" 
      value="/c:wrap/epub-config/checks/check[@param = 'image-min-width']
                                             [@severity = 'warning']/@value"/>
  </pattern>
  
  <pattern id="image-too-tall-error" is-a="image-dims">
    <param name="severity" value="error"/>
    <param name="width-or-height" value="'height'"/>
    <param name="min-or-max" value="'max'"/>
    <param name="threshold" 
      value="/c:wrap/epub-config/checks/check[@param = 'image-max-height']
                                             [@severity = 'error' or empty(@severity)]/@value"/>
  </pattern>
  
  <pattern id="image-too-tall-warning" is-a="image-dims">
    <param name="severity" value="warning"/>
    <param name="width-or-height" value="'height'"/>
    <param name="min-or-max" value="'max'"/>
    <param name="threshold" 
      value="/c:wrap/epub-config/checks/check[@param = 'image-max-height']
                                             [@severity = 'warning']/@value"/>
  </pattern>
  
  <pattern id="image-too-small-error" is-a="image-dims">
    <param name="severity" value="error"/>
    <param name="width-or-height" value="'height'"/>
    <param name="min-or-max" value="'min'"/>
    <param name="threshold"
      value="/c:wrap/epub-config/checks/check[@param = 'image-min-height']
                                             [@severity = 'error' or empty(@severity)]/@value"/>
  </pattern>
  
  <pattern id="image-too-small-warning" is-a="image-dims">
    <param name="severity" value="warning"/>
    <param name="width-or-height" value="'height'"/>
    <param name="min-or-max" value="'min'"/>
    <param name="threshold" 
      value="/c:wrap/epub-config/checks/check[@param = 'image-min-height']
                                             [@severity = 'warning']/@value"/>
  </pattern>
  
  

  <pattern id="file-size" abstract="true">
    <rule context="opf:item[matches(@media-type, '^image/(jpeg|png|gif)')]">
      <extends rule="file-calc"/>
      <!-- we need this variable for the diagnostics (the params don’t seem to be in scope there): -->
      <let name="max" value="$image-max-mb"/>
      <report test="$size-in-mb &gt; $max" id="large-image-file" 
        diagnostics="large-image-file_de" role="$severity">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
        Image file '<value-of select="@href"/>' is quite large: <value-of select="format-number($size-in-mb, '#0.00')"/>&#xa0;MB
      </report>
    </rule>
  </pattern>

  <pattern id="file-size-warnings" is-a="file-size">
    <param name="severity" value="warning"/>
    <param name="image-max-mb" 
      value="/c:wrap/epub-config/checks/check[@param = 'image-max-mb'][@severity = 'warning']/@value"/>
  </pattern>
  
  <pattern id="file-size-errors" is-a="file-size">
    <param name="severity" value="error"/>
    <param name="image-max-mb" 
      value="/c:wrap/epub-config/checks/check[@param = 'image-max-mb']
                                             [@severity = 'error' or empty(@severity)]/@value"/>
  </pattern>

  <pattern id="image-formats" abstract="true">
    <rule context="opf:item[matches(@media-type, '^image/')]">
      <extends rule="file-calc"/>
      <let name="allowed" value="$image-type-regex"/>
      <assert test="matches(@media-type, $allowed)" id="image-type" diagnostics="image-type_de" role="$severity">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
        The media type of image '<value-of select="@href"/>', '<value-of select="@media-type"/>', does not comply with the regex '<value-of 
          select="$allowed"/>'.
      </assert>
    </rule>
  </pattern>

  <pattern id="image-format-warnings" is-a="image-formats">
    <param name="severity" value="warning"/>
    <param name="image-type-regex" 
      value="(/c:wrap/epub-config/checks/check[@param = 'image-type-regex'][@severity = 'warning']/@value, '^image/')[1]"/>
  </pattern>

  <pattern id="image-format-errors" is-a="image-formats">
    <param name="severity" value="error"/>
    <param name="image-type-regex" 
      value="(/c:wrap/epub-config/checks/check[@param = 'image-type-regex']
                                              [@severity = 'error' or empty(@severity)]/@value, '^image/')[1]"/>
  </pattern>


  <pattern id="cmyk">
    <rule context="opf:item[@media-type = 'image/jpeg']">
      <extends rule="file-calc"/>      
      <report test="$colorspace = 'CMYK'" id="cmyk-image" diagnostics="cmyk-image_de" role="warning">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
        Image '<value-of select="@href"/>' is CMYK. This is not supported by every reading system.
      </report>
    </rule>
  </pattern>

  <pattern id="dpi" abstract="true">
    <rule context="opf:item[matches(@media-type, '^image/(jpeg|png)')]">
      <extends rule="file-calc"/>
      <!-- we need these variables for the diagnostics (the params don’t seem to be in scope there): -->
      <let name="min" value="$image-min-dpi"/>
      <let name="max" value="$image-max-dpi"/>
      <report test="$dpi[not(. = 0)] &gt; $max" id="max-dpi" diagnostics="max-dpi_de" role="$severity">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
        Image '<value-of select="@href"/>' has a dpi value of <value-of select="$dpi"/>. 
        It should be less than or equal <value-of select="$max"/>.
      </report>
      <report test="$dpi[not(. = 0)] &lt; $min" id="min-dpi" diagnostics="min-dpi_de" role="$severity">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
        Image '<value-of select="@href"/>' has a dpi value of <value-of select="$dpi"/>. 
        It should be greater than or equal <value-of select="$min"/>.
      </report>
    </rule>
  </pattern>
  
  <pattern id="dpi-warnings" is-a="dpi">
    <param name="severity" value="warning"/>
    <param name="image-min-dpi" 
      value="/c:wrap/epub-config/checks/check[@param = 'image-min-dpi'][@severity = 'warning']/@value"/>
    <param name="image-max-dpi" 
      value="/c:wrap/epub-config/checks/check[@param = 'image-max-dpi'][@severity = 'warning']/@value"/>
  </pattern>
  
  <pattern id="dpi-errors" is-a="dpi">
    <param name="severity" value="error"/>
    <param name="image-min-dpi" 
      value="/c:wrap/epub-config/checks/check[@param = 'image-min-dpi']
                                             [@severity = 'error' or not(@severity)]/@value"/>
    <param name="image-max-dpi" 
      value="/c:wrap/epub-config/checks/check[@param = 'image-max-dpi']
                                             [@severity = 'error' or not(@severity)]/@value"/>
  </pattern>

  <pattern id="links">
    <!-- Both assertions are also checked against in epubcheck. These checks also locate the error in the source HTML. -->
    <rule context="/c:wrap/cx:document[@name = 'wrap-chunks']
                     /html:html
                       //html:a[@href][not(matches(@href, '^(#|https?:|mailto:|ftp:)', 'i'))]">
      <let name="srcpath" value="tokenize(ancestor-or-self::*[@srcpath][1]/@srcpath, '\s+')"/>
      <let name="base-uri" value="ancestor::html:html/@xml:base"/>
      <let name="resolved" value="tr:uri-composer($base-uri, @href)"/>
      <let name="normalized" value="replace($resolved, '^.+/(OEBPS/[^?#%]+).*$', '$1')"/>
      <let name="fragment-id" value="substring-after($resolved, '#')[normalize-space()]"/>
      <assert test="$normalized = $oebps-paths" role="error" id="link-to-file" diagnostics="link-to-file_de">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
        Links in the input document must point to an internal anchor, to another file in the archive or to an external site.
        This link points to: '<value-of select="$normalized"/>'. resolved: '<value-of select="$resolved"/>'. href: '<value-of select="@href"/>'. base-uri: '<value-of select="$base-uri"/>'
      </assert>
      <assert test="if ($fragment-id) 
                    then exists(/c:wrap/cx:document[@name = 'wrap-chunks']/html:html[ends-with(@xml:base, $normalized)]//@id[. = $fragment-id])
                    else true()"
        id="link-to-id" role="warning" diagnostics="link-to-id_de">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
        The ID '<value-of select="$fragment-id"/>' in file '<value-of select="$normalized"/>' does not exist.
      </assert>
    </rule>
    <rule context="/c:wrap/cx:document[@name = 'wrap-chunks']
                     /html:html[@xml:base = /c:wrap/cx:document[@name = 'wrap-file-uris']/c:file/@target-filename]
                       //html:a[not(@href)][normalize-space(.)]">
      <let name="srcpath" value="tokenize(ancestor-or-self::*[@srcpath][1]/@srcpath, '\s+')"/>
      <let name="orig-href" value="/c:wrap/html:html//html:a[@srcpath = $srcpath]/@href"/>
      <report test="exists($orig-href)" role="warning" id="dissolved-link" diagnostics="dissolved-link_de">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
        The link’s @href attribute '<value-of select="$orig-href"/>' could not be resolved and it was discarded during conversion.
        Content of the link: '<value-of select="."/>'.
      </report>
    </rule>
  </pattern>

  <pattern id="contains-a">
    <rule context="/c:wrap/cx:document[@name = 'wrap-chunks']
                     /html:html
                       //html:a">
      <report test="descendant::html:a" role="error" id="contains-a-element" diagnostics="contains-a-element_de">
        <span class="srcpath"><xsl:value-of select="for $s in tokenize(@srcpath, '\s+') return concat($source-dir-uri, $s)"/></span>
        This &lt;a&gt; element (<value-of select="string-join(for $a in (@* except @srcpath) return concat($a/name(), '=', $a), ', ')"/>) contains at least one other &lt;a&gt; element.
      </report>
    </rule>
  </pattern>

  <pattern id="nested-a">
    <rule context="/c:wrap/cx:document[@name = 'wrap-chunks']
                     /html:html
                       //html:a">
      <report test="ancestor::html:a" role="error" id="nested-a-element" diagnostics="nested-a-element_de">
        <span class="srcpath"><xsl:value-of select="for $s in tokenize(@srcpath, '\s+') return concat($source-dir-uri, $s)"/></span>
        This &lt;a&gt; element  (<value-of select="string-join(for $a in (@* except @srcpath) return concat($a/name(), '=', $a), ', ')"/>) is nested within another &lt;a&gt; element.
      </report>
    </rule>
  </pattern>
  
  <pattern id="unwrapped-text">
    <rule context="/c:wrap/html:html[1]//*[local-name() = $containers]">
      <let name="atts" value="@* except @srcpath"/>
      <let name="atts-string" value="if ($atts) 
        then concat('(', string-join(for $a in $atts return concat($a/name(), '=', $a), ', '), ') ')
        else ''"/>
      <let name="occurrences" value="string-join(for $t in text()[normalize-space()] return concat('''', $t, ''''), ', ')"/>
      <report test="text()[normalize-space()]" role="warning" id="bare-text" diagnostics="bare-text_de">
        <span class="srcpath"><xsl:value-of select="for $s in tokenize(descendant-or-self::*[@srcpath][1]/@srcpath, '\s+') 
                                                    return concat($source-dir-uri, $s)"/></span>
        The container element '<name/>' <xsl:value-of select="$atts-string"/> contains untagged text: <value-of select="$occurrences"/>.
        Although this may be permitted by the HTML schema, it should be avoided. We report it as an error since it is
        an indication of mistakes in applying correct document styles or flaws in the conversion process.
      </report>
    </rule>
  </pattern>
  
  <pattern id="cover">
    <rule context="/c:wrap/cx:document[@name = 'wrap-chunks']/html:html//*[@id = 'epub-cover-image-container']">
      <let name="srcpath" value="tokenize(ancestor-or-self::*[@srcpath][1]/@srcpath, '\s+')"/>
      <report test="exists(html:p[@class = 'error'])" role="error" id="cover-retrieval" diagnostics="cover-retrieval_de">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
        Apparently there was a problem attaching the cover: <xsl:copy-of select="html:p[@class = 'error']/node()"/>
      </report>
    </rule>
  </pattern>

  <pattern id="languages">
    <rule context="/c:wrap/html:html[1][@lang | @xml:lang] | /c:wrap/html:html[1]//*[@lang | @xml:lang]">
      <let name="srcpath" value="if (self::html:html) 
                                 then 'BC_orphans' 
                                 else 
                                    for $s in (tokenize(@srcpath, '\s+')) 
                                    return concat($source-dir-uri, $s)"/>
      <report test="not(@lang)" role="warning" id="xml-lang" diagnostics="xml-lang_de">
        <span class="srcpath"><xsl:value-of select="$srcpath"/></span>
        You should also set @lang in addition to @xml:lang
      </report>
      <report test="@lang != @xml:lang" role="warning" id="lang-not-equal-xml-lang" diagnostics="lang-not-equal-xml-lang_de">
        <span class="srcpath"><xsl:value-of select="$srcpath"/></span>
         @lang '<value-of select="@lang"/>' and @xml:lang '<value-of select="@xml:lang"/>' differ
      </report>
      <report test="true()" role="info" id="lang" diagnostics="lang_de">
        <span class="srcpath"><xsl:value-of select="$srcpath"/></span>
        <span class="corrected-id"><xsl:value-of select="string-join(('lang', distinct-values(@xml:lang | @lang)), '-')"/></span>
        HTML element '<value-of select="name()"/>' with lang attribute '<value-of select="distinct-values(@xml:lang | @lang)"/>'
      </report>
    </rule>
     <rule context="/c:wrap/epub-config[1]/metadata[1]/dc:language">
      <report test="true()" role="info" id="doc_language" diagnostics="doc_language_de">
      <span class="srcpath"><xsl:value-of select="'BC_orphans'"/></span>
        Document language according to dc:language: <xsl:value-of select="."/> 
      </report>
    </rule>
    <rule context="/c:wrap">
      <report test="html:html[1]//*[@lang | @xml:lang]" role="info" id="other_languages" diagnostics="other_languages_de">
      <span class="srcpath"><xsl:value-of select="'BC_orphans'"/></span>
        Other Language codes and number of their occurrences: 
        <xsl:variable name="occ" select="html:html[1]//*[@xml:lang|@lang]"/>
        <ul xmlns="http://www.w3.org/1999/xhtml">
           <xsl:for-each select="distinct-values(html:html[1]//*[@xml:lang|@lang]/@*[local-name() = 'lang'][1])">
             <li><xsl:value-of select="current()"/> :  <xsl:value-of select="count($occ[@*[local-name() = 'lang'][1]=current()])"/></li>
           </xsl:for-each> 
        </ul>
      </report>
    </rule>
  </pattern>

  <pattern id="splits">
    <rule context="/c:wrap/html:body//html:tr-conditional-split[not(@tr-dont-split-at-genid)]">
      <let name="doc-elt" value="/c:wrap/cx:document[@name = 'wrap-chunks']//*[@id = current()/@tr-generated-id]"/>
      <let name="srcpath" value="$doc-elt/descendant-or-self::*[@srcpath][not(self::html:div)][1]/@srcpath"/>
      <report test="true()" role="info" id="conditional_split" diagnostics="conditional_split_de">
        <span class="srcpath"><xsl:value-of select="$srcpath"/></span>
        Conditional split before '<value-of select="substring(normalize-space($doc-elt), 1, 30)"/>…'.
      </report>
    </rule>
  </pattern>
  
  <pattern id="empty-chunks">
    <rule context="/c:wrap/cx:document[@name = 'wrap-chunks']/html:html/html:body[not(@epub:type = 'cover')]">
      <let name="srcpath" value="tokenize(descendant-or-self::*[@srcpath][1]/@srcpath, '\s+')"/>
      <let name="elements" value="string-join(for $n in .//* 
                                              return concat('&lt;', name($n), ' ',
                                                             string-join(
                                                               for $a in $n/@*[not(name() = 'srcpath')] return concat(name($a), '=', $a),
                                                               ' '
                                                             ),
                                                             '&gt;'
                                                           ), 
                                              ', ')"/>
      <assert test="normalize-space(.) or exists(.//html:img | .//svg:svg)" role="warning" id="no-text-in-chunk" diagnostics="no-text-in-chunk_de">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
        Empty split chunk. <xsl:value-of select="if (*) then $elements else 'Doesn’t contain any tagging at all.'"/>
      </assert>
    </rule>
  </pattern>

  <pattern id="newline-in-chunks">
    <rule context="/c:wrap/cx:document[@name = 'wrap-chunks']/html:html/html:body[not(@epub:type = 'cover')]">
      <let name="srcpath" value="tokenize(descendant-or-self::*[@srcpath][1]/@srcpath, '\s+')"/>
      <let name="newline-regex" value="'(&#x85;|&#x2028;|&#x2029;|&#xd;&#xa;|&#x10fb;)'"/>
      <report test="matches(string-join(descendant::text(),''),$newline-regex)" role="warning" id="newline-in-chunk" diagnostics="newline-in-chunk_de">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
       Inapropriate newline character used: <xsl:value-of select="descendant::*[matches(string-join(text(),''),$newline-regex)]/text()"/>
      </report>
    </rule>
  </pattern>

  <pattern id="http-resources">
    <rule context="/c:wrap/html:html//*[@error-status = '999']">
      <let name="srcpath" value="tokenize(ancestor-or-self::*[@srcpath][1]/@srcpath, '\s+')"/>
      <report test="true()" role="warning" id="resource-checking-failed" diagnostics="resource-unavailable_de">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
        Resource unavailable: <a xmlns="http://www.w3.org/1999/xhtml" href="{@checked-href}"><xsl:value-of select="@checked-href"/></a>. 
        Status: <value-of select="@error-status"/>. A status of 999
        indicates that the HTTP client library failed to access the resource. This may be because the target site does not exist 
        or it might also be a communication error of the HTTP client. 
        The resource may still be available. Please check it manually in the browser.
      </report>
    </rule>
    <rule context="/c:wrap/html:html//*[@error-status]">
      <let name="srcpath" value="tokenize(ancestor-or-self::*[@srcpath][1]/@srcpath, '\s+')"/>
      <report test="true()" role="warning" id="resource-unavailable" diagnostics="resource-unavailable_de">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
        Resource unavailable: <a xmlns="http://www.w3.org/1999/xhtml" href="{@checked-href}"><xsl:value-of select="@checked-href"/></a>. 
        Status: <value-of select="@error-status"/>
      </report>
    </rule>
  </pattern>

  <pattern id="metadata">
    <rule context="opf:package">
      <assert test="exists(@version) and @version = ('2.0', '3.0')" role="error" id="version" diagnostics="version_de">
        <span class="srcpath">BC_orphans</span>content.opf: /package/@version must be 2.0 or 3.0. Found: <value-of
          select="$epub-version"/>
      </assert>
      <assert test="if ($epub-version = '2.0') 
                    then exists(opf:guide)
                    else true()" id="guide" diagnostics="guide_de" role="warning">
        <span class="srcpath">BC_orphans</span>content.opf should contain a guide
      </assert>
    </rule>
    <rule context="opf:package/opf:metadata">
      <let name="mandatory-metadata" value="('dc:title', 'dc:identifier', 'dc:language')"/>
      <let name="optional-dc-metadata" value="('dc:contributor', 'dc:coverage', 'dc:creator', 'dc:date', 'dc:description', 
        'dc:format', 'dc:publisher', 'dc:relation', 'dc:rights', 'dc:source', 'dc:subject', 'dc:type')"/>
      <let name="missing" value="string-join($mandatory-metadata[for $me in . return not(exists(current()/*[name() = $me]))], ', ')"/>
      <assert test="every $e in $mandatory-metadata satisfies (exists(*[name() = $e]))" id="mandatory-metadata" 
        diagnostics="mandatory-metadata_de" role="error">
        <span class="srcpath">BC_orphans</span> content.opf: The following metadata elements are missing: <value-of 
          select="$missing"/>.</assert>
      <!-- Will be checked by epubcheck schema validation <report test="dc:*[not(name() = ($mandatory-metadata, $optional-dc-metadata))]" id="unrecognized-dc-metadata" role="error">
        <span class="srcpath">BC_orphans</span> content.opf: The following metadata elements are unexpected: <value-of 
          select="string-join(for $n in dc:*[not(name() = ($mandatory-metadata, $optional-dc-metadata))]/name() 
                              return concat('''', $n, ''''), ', ')"/>.
      </report>-->
      <assert test="if ($epub-version = '3.0') 
                    then exists(opf:meta[@property = 'dcterms:modified'][. castable as xs:dateTime])
                    else true()" id="modification-date-missing-epub3"
         diagnostics="modification-date-missing-epub3_de" role="warning">
        <span class="srcpath">BC_orphans</span> content.opf: There should be an opf:metadata/opf:meta[@property = 'dcterms:modified'],
        and it should contain a datetime string.</assert>
      <assert test="if ($epub-version = '2.0')
                    then exists(dc:date[@opf:event = 'modification'])
                    else true()" id="modification-date-missing-epub2"
         diagnostics="modification-date-missing-epub2_de" role="warning">
        <span class="srcpath">BC_orphans</span> content.opf: There should be an opf:metadata/dc:date[@opf:event = 'modification'].</assert>
      <assert test="if ($epub-version = '2.0') 
                    then exists(opf:meta[@name = 'cover'])
                    else true()" role="warning" id="meta-cover" diagnostics="meta-cover_de">
        <span class="srcpath">BC_orphans</span> content.opf: For best reading system support, there must be an 
        element opf:metadata/opf:meta[@name = 'cover'] in EPUB2 publications.
      </assert>
      <!-- Is this really needed? <assert test="if ($epub-version = '3.0') 
                    then exists(opf:meta[@name = 'cover'])
                    else true()" role="warning" id="meta-cover-3" diagnostics="meta-cover-3_de">
        <span class="srcpath">BC_orphans</span> content.opf: For best reading system support, there should be an 
        element opf:metadata/opf:meta[@name = 'cover'].
      </assert>-->
      <report test="*[starts-with(name(), 'dc:')]" role="info" id="meta-tags" diagnostics="meta-tags_de">
        <span class="srcpath">BC_orphans</span>
        EPUB meta tags:<br xmlns="http://www.w3.org/1999/xhtml"/><br xmlns="http://www.w3.org/1999/xhtml"/>
        <ul xmlns="http://www.w3.org/1999/xhtml">
          <xsl:for-each select="*[starts-with(name(), 'dc:')]">
            <li><b><xsl:value-of select="local-name()"/>: </b><xsl:value-of select="."/></li>
          </xsl:for-each>
          <li><b><xsl:value-of select="'EPUB version'"/>: </b><xsl:value-of select="../@version"/></li>
        </ul>
      </report>
    </rule>

    <rule context="opf:package/opf:metadata/opf:meta[@name = 'cover']">
      <let name="item" value="../../opf:manifest/opf:item[@id = current()/@content]"/>
      <let name="regex" value="concat('(^|/)', $item/@href, '$')"/>
      <let name="element-in-split" 
        value="/c:wrap/cx:document[@name = 'wrap-chunks']//(
                                                               html:img[matches(@src, $regex)] 
                                                             | svg:image[matches(@xlink:href, $regex)]
                                                            )"/>
      <let name="srcpath" value="for $s in $element-in-split/ancestor-or-self::*[@srcpath][1]/@srcpath return tokenize($s, '\s+')"/>
      <assert test="exists($item)" role="error" 
        id="meta-cover-points-nowhere-in-manifest" diagnostics="meta-cover-points-nowhere-in-manifest_de">
        <span class="srcpath">BC_orphans</span> 
          There is no manifest entry for opf:metadata/opf:meta[@name = 'cover']/@content = '<value-of select="@content"/>'.
      </assert>
      <assert test="if (exists($item)) then exists($element-in-split) else true()" role="error" 
        id="meta-cover-points-nowhere-in-content" diagnostics="meta-cover-points-nowhere-in-content_de">
        <span class="srcpath">BC_orphans</span> Image file
          '<value-of select="$item/@href"/>' is marked as cover in opf:metadata/opf:meta[@name = 'cover']. However, this
        file does not seem to be used in any of the HTML pages.
      </assert>
      <assert test="if (exists($element-in-split)) 
                    then (
                          exists($element-in-split/ancestor::*/@srcpath = 'epub-cover')
                          or
                          exists($element-in-split/ancestor::*/@id = 'epub-cover-image-container')
                         )
                    else true()" role="warning" id="meta-cover-points-to-non-cover" diagnostics="meta-cover-points-to-non-cover_de">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span> Image file
          '<value-of select="$item/@href"/>' should be included in an element that has (or once had) epub:type='cover'. It may be 
      ok to refer to the same image twice, but it must also be referred to in the designated cover div.</assert>
    </rule>
  </pattern>
  
  <pattern id="empty-alt-pattern">
    <rule context="/c:wrap/cx:document[@name = 'wrap-chunks']//html:img[@alt]">
      <assert role="warning" test="normalize-space(@alt) or @role = 'presentation' " id="empty-img-alt" diagnostics="empty-img-alt_de">
        <span class="srcpath"><xsl:value-of select="for $s in @srcpath return concat($source-dir-uri, $s)"/></span>
        The alt attribute on image '<value-of select="replace(@src, '^.+/', '')"/>' is empty. This is only
        recommended for decorative images that don't add information to the content and can be ignored by assistive 
        technologies, such as screen readers.
      </assert>
    </rule>
  </pattern>

  <pattern id="check-alt-texts">
    <rule context="/c:wrap/cx:document[@name = 'wrap-chunks']//html:img">
      <report role="info" id="print-alt-texts" diagnostics="print-alt-texts_de" 
              test="exists(/c:wrap/epub-config/checks/check[@param = 'check-alt-texts']
                                                           [@value = ('true', 'yes')])">
         <span class="srcpath"><xsl:value-of select="for $s in @srcpath return concat($source-dir-uri, $s)"/></span>
        Alt text: '<value-of select="@alt"/>'.
      </report>
    </rule>
  </pattern>

  <pattern id="metadata-title">
    <rule context="opf:package/opf:metadata/dc:title">
      <report test="matches(., '^[\p{Zs}\s]*$')" role="error" id="empty-title" diagnostics="empty-title_de">
        <span class="srcpath">BC_orphans</span> content.opf: metadata/dc:title must not be empty. 
      </report>
    </rule>    
  </pattern>

  <pattern id="structural-vocabulary">
    <!-- Retrieved on 2015-10-25 with 
      string-join(for $d in distinct-values(doc('http://www.idpf.org/epub/vocab/structure/')//*:dl[@rev='rdfs:member']/*:dt) 
                  return concat('''', normalize-space($d), ''''), ', ') 
      then removed ' [draft]' and removed the items marked as ' [deprecated]' -->
    <let name="epub-types" value="('cover', 'frontmatter', 'bodymatter', 'backmatter', 'volume', 'part', 'chapter', 
      'division', 'abstract', 'foreword', 'preface', 'prologue', 'introduction', 'preamble', 'conclusion', 
      'epilogue', 'afterword', 'epigraph', 'toc', 'toc-brief', 'landmarks', 'loa', 'loi', 'lot', 'lov', 'appendix', 
      'colophon', 'credits', 'keywords', 'index', 'index-headnotes', 'index-legend', 'index-group', 'index-entry-list', 
      'index-entry', 'index-term', 'index-editor-note', 'index-locator', 'index-locator-list', 'index-locator-range', 
      'index-xref-preferred', 'index-xref-related', 'index-term-category', 'index-term-categories', 'glossary', 'glossterm', 
      'glossdef', 'bibliography', 'biblioentry', 'titlepage', 'halftitlepage', 'copyright-page', 'seriespage', 
      'acknowledgments', 'imprint', 'imprimatur', 'contributors', 'other-credits', 'errata', 'dedication', 
      'revision-history', 'case-study', 'notice', 'pullquote', 'tip', 'halftitle', 'fulltitle', 'covertitle', 'title', 
      'subtitle', 'label', 'ordinal', 'bridgehead', 'learning-objective', 'learning-objectives', 'learning-outcome', 
      'learning-outcomes', 'learning-resource', 'learning-resources', 'learning-standard', 'learning-standards', 'answer', 
      'answers', 'assessment', 'assessments', 'feedback', 'fill-in-the-blank-problem', 'general-problem', 'qna', 
      'match-problem', 'multiple-choice-problem', 'practice', 'practices', 'question', 'true-false-problem', 'panel', 
      'panel-group', 'balloon', 'text-area', 'sound-area', 'footnote', 'endnote', 'footnotes', 'endnotes', 'annoref', 
      'biblioref', 'glossref', 'noteref', 'backlink', 'credit', 'keyword', 'topic-sentence', 'concluding-sentence', 'pagebreak', 
      'page-list', 'table', 'table-row', 'table-cell', 'list', 'list-item', 'figure', 'aside')"/>
    <rule context="/c:wrap/html:html[1]/html:body//*[@epub:type]">
      <let name="actual-types" value="tokenize(@epub:type, '\s+')[not(contains(., ':'))]"/>
      <let name="namespaced-types" value="tokenize(@epub:type, '\s+')[contains(., ':')]"/>
      <let name="wrong-type-string" 
        value="string-join(for $t in $actual-types[not(. = $epub-types)] return concat('''', $t, ''''), ', ')"/>
      <let name="namespaced-type-string" 
        value="string-join(for $t in $namespaced-types return concat('''', $t, ''''), ', ')"/>
      <let name="allowed-type-string" value="string-join(for $t in $epub-types return concat('''', $t, ''''), ', ')"/>
      <assert test="every $t in $actual-types satisfies ($t = $epub-types)" 
        id="epub-type" role="warning" diagnostics="epub-type_de">
        <span class="srcpath"><xsl:value-of select="for $s in tokenize(@srcpath, '\s+') return concat($source-dir-uri, $s)"/></span>
        epub:type <xsl:value-of select="$wrong-type-string"/> not allowed. Allowed values according to <a 
          xmlns="http://www.w3.org/1999/xhtml" 
          href="http://www.idpf.org/epub/vocab/structure/">EPUB 3 Structural Semantics Vocabulary</a> (as of 2019-05-08): 
        <xsl:value-of select="$allowed-type-string"/>.
      </assert>
      <report test="exists($namespaced-types)" 
        id="custom-epub-type" role="info" diagnostics="custom-epub-type_de">
        <span class="srcpath"><xsl:value-of select="for $s in tokenize(@srcpath, '\s+') return concat($source-dir-uri, $s)"/></span>
        Namespaced (custom) epub:type: <xsl:value-of select="$namespaced-type-string"/>.
      </report>
    </rule>
  </pattern>
  
  <pattern id="para-checks">
    <rule context="/c:wrap/html:html[1]/html:body//html:p">
      <let name="srcpath" value="tokenize(descendant-or-self::*[@srcpath][1]/@srcpath, '\s+')"/>
      <let name="para-max-string-length" value="/c:wrap/epub-config/checks/check[@param = 'para-max-string-length']/@value"/>
      <report diagnostics="paragraph-very-long_de" role="error" id="paragraph-very-long"
              test="string-length(normalize-space(string-join(descendant::text(), ''))) &gt; $para-max-string-length">
        <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
        This paragraph consists of more than <value-of select="$para-max-string-length"/> characters and may affect performance of the e-reader or even cause it to crash. 
      </report>
    </rule>
  </pattern>
  
  <pattern id="page_numbers">
    <rule context="ncx:pageList/ncx:pageTarget">
      <report test="tr:roman-or-int-to-int(ncx:navLabel/ncx:text) 
                    &lt; tr:roman-or-int-to-int(preceding-sibling::ncx:pageTarget[1]/ncx:navLabel/ncx:text)"
        id="page_numbers_ncx-not-ascending" role="warning" diagnostics="page_numbers_ncx-not-ascending_de">
        An NCX pageList page number, <xsl:value-of select="ncx:navLabel/ncx:text"/>, is smaller than the preceding page number,
        which is <xsl:value-of select="preceding-sibling::ncx:pageTarget[1]/ncx:navLabel/ncx:text"/>.
      </report>
    </rule>
  </pattern>
  
  <pattern id="table-string-length" abstract="true">
    <rule context="/c:wrap/html:html[1]/html:body//html:table">
      <extends rule="file-calc"/>
      <let name="max" value="$table-max-str-length"/>
      <let name="str-length" value="string-length(string-join(.//*[local-name() = ('caption', 'td', 'th')]))"/>
      <let name="srcpath" value="tokenize(descendant-or-self::*[@srcpath][1]/@srcpath, '\s+')"/>
      <report test="$str-length &gt; $max" id="table-str-length" 
              diagnostics="table-string-length_de" role="$severity">
        <span class="srcpath"><xsl:value-of select="$srcpath"/></span>
        The table contains <value-of select="$str-length"/> characters and exceeds the limit of <value-of select="$max"/>.
        Amazon does not support tables with more than <value-of select="$max"/> characters.
        More information is available in the <a xmlns="http://www.w3.org/1999/xhtml" href="https://kdp.amazon.com/en_US/help/topic/GZ8BAXASXKB5JVML#large_tables" target="_blank">Kindle Publishing Guidelines</a>.
      </report>
    </rule>
  </pattern>
  
  <pattern id="table-string-length-warnings" is-a="table-string-length">
    <param name="severity" value="warning"/>
    <param name="table-max-str-length" 
           value="/c:wrap/epub-config/checks/check[@param = 'table-max-str-length'][@severity = 'warning']/@value"/>
  </pattern>
  
  <pattern id="table-string-length-errors" is-a="table-string-length">
    <param name="severity" value="error"/>
    <param name="table-max-str-length" 
           value="/c:wrap/epub-config/checks/check[@param = 'table-max-str-length'][@severity = 'error']/@value"/>
  </pattern>
  
  <pattern id="table-cells" abstract="true">
    <rule context="/c:wrap/html:html[1]/html:body//html:table">
      <extends rule="file-calc"/>
      <let name="max" value="$table-max-cell-count"/>
      <let name="cell-count" value="count(.//*[local-name() = ('td', 'th')])"/>
      <let name="srcpath" value="tokenize(descendant-or-self::*[@srcpath][1]/@srcpath, '\s+')"/>
      <report test="$cell-count &gt; $max" id="table-cell-count" 
              diagnostics="table-cell-count_de" role="$severity">
        <span class="srcpath"><xsl:value-of select="$srcpath"/></span>
        The table contains <value-of select="$cell-count"/> cells which exceeds the limit of <value-of select="$max"/>.
        Amazon does not support tables with more than <value-of select="$max"/> cells.
        More information is available in the <a xmlns="http://www.w3.org/1999/xhtml" href="https://kdp.amazon.com/en_US/help/topic/GZ8BAXASXKB5JVML#large_tables" target="_blank">Kindle Publishing Guidelines</a>.
      </report>
    </rule>
  </pattern>
  
  <pattern id="table-cell-count-warnings" is-a="table-cells">
    <param name="severity" value="warning"/>
    <param name="table-max-cell-count" 
           value="/c:wrap/epub-config/checks/check[@param = 'table-max-cell-count'][@severity = 'warning']/@value"/>
  </pattern>
  
  <pattern id="table-cell-count-errors" is-a="table-cells">
    <param name="severity" value="error"/>
    <param name="table-max-cell-count" 
           value="/c:wrap/epub-config/checks/check[@param = 'table-max-cell-count'][@severity = 'error']/@value"/>
  </pattern>
  
  <diagnostics>
    <diagnostic id="print-alt-texts_de" xml:lang="de">
       Alternativtext: '<value-of select="@alt"/>'.
    </diagnostic>
    <diagnostic id="page_numbers_ncx-not-ascending_de" xml:lang="de">
      Eine Seitenzahl in der NCX-pageList, <xsl:value-of select="ncx:navLabel/ncx:text"/>, ist kleiner als die Vorgängerseitenzahl,
        <xsl:value-of select="preceding-sibling::ncx:pageTarget[1]/ncx:navLabel/ncx:text"/>.
    </diagnostic>
    <diagnostic id="other_languages_de" xml:lang="de">Weitere Sprachangaben und die Anzahl ihrer Verwendung: 
      <xsl:variable name="occ" select="html:html[1]//*[@xml:lang|@lang]"/>
      <ul xmlns="http://www.w3.org/1999/xhtml">
        <xsl:for-each select="distinct-values(html:html[1]//*[@xml:lang|@lang]/@*[local-name() = 'lang'][1])">
             <li><xsl:value-of select="current()"/> :  <xsl:value-of select="count($occ[@*[local-name() = 'lang'][1]=current()])"/></li>
           </xsl:for-each> 
      </ul></diagnostic>
    <diagnostic id="lang-not-equal-xml-lang_de" xml:lang="de">@lang '<value-of select="@lang"/>' und @xml:lang '<value-of select="@xml:lang"/>' wichen voneinander ab!</diagnostic>
    <diagnostic id="xml-lang_de" xml:lang="de">Es sollte auch das Attribut @lang zusätzlich zu @xml:lang gesetzt werden!</diagnostic>
    <diagnostic id="lang_de" xml:lang="de"> HTML-Element '<value-of select="name()"/>' mit lang-Attribut '<value-of select="distinct-values(@xml:lang | @lang)"/>'
    </diagnostic>
    <diagnostic id="doc_language_de" xml:lang="de">Sprache des Dokumentes laut Metadatenelement (dc:language): <xsl:value-of select="."/> 
    </diagnostic>
    <diagnostic id="image-dimensions_de" xml:lang="de">Pixel-<value-of select="if ($_width-or-height = 'height') then
      'Höhe' else 'Breite'"/> von Bild '<value-of select="@href"/>' zu <value-of 
        select="if ($_min-or-max = 'min') then 'klein' else 'groß'"/>. Wert: <value-of select="$actual-dim"/>. Schwellwert: <value-of 
          select="$_threshold"/>.
    </diagnostic>
    <diagnostic id="custom-epub-type_de" xml:lang="de">epub:type in Namespace (Nicht-Standard-Wert): <xsl:value-of 
      select="$namespaced-type-string"/>.</diagnostic>
    <diagnostic id="version_de" xml:lang="de">content.opf: /package/@version muss 2.0 oder 3.0 sein. Gefunden: <value-of
          select="$epub-version"/></diagnostic>
    <diagnostic id="guide_de" xml:lang="de">content.opf sollte ein guide-Element enthalten.</diagnostic>
    <diagnostic id="epub-type_de" xml:lang="de">epub:type <xsl:value-of select="$wrong-type-string"/> ist nicht zulässig. 
      Zulässige Werte gemäß <a 
          xmlns="http://www.w3.org/1999/xhtml" 
          href="http://www.idpf.org/epub/vocab/structure/">EPUB 3 Structural Semantics Vocabulary</a> (Stand 2019-05-08): 
      <xsl:value-of select="$allowed-type-string"/>.</diagnostic>
  	<diagnostic id="meta-tags_de" xml:lang="de">EPUB Metadaten:<br xmlns="http://www.w3.org/1999/xhtml"/><br xmlns="http://www.w3.org/1999/xhtml"/>
    			<ul xmlns="http://www.w3.org/1999/xhtml">
    				<xsl:for-each select="*[starts-with(name(), 'dc:')]">
    					<li><b><xsl:value-of select="local-name()"/>: </b><xsl:value-of select="."/></li>
    				</xsl:for-each>
            <li><b><xsl:value-of select="'EPUB version'"/>: </b><xsl:value-of select="../@version"/></li>
    			</ul>
  	</diagnostic>
    <diagnostic id="meta-cover_de" xml:lang="de">content.opf: Für optimale Lesesystem-Unterstützung muss ein
        Element opf:metadata/opf:meta[@name = 'cover'] in EPUB2-Publikationen angegeben werden.</diagnostic>
    <diagnostic id="mandatory-metadata_de" xml:lang="de">content.opf: Die folgenden erforderlichen Metadaten-Elemente fehlen: 
      <value-of select="$missing"/>.</diagnostic>
    <diagnostic id="modification-date-missing-epub2_de" xml:lang="de">content.opf: Das Datum der letzten Änderung sollte mittels 
      opf:metadata/dc:date[@opf:event = 'modification'] angegeben werden.</diagnostic>
    <diagnostic id="modification-date-missing-epub3_de" xml:lang="de">content.opf: Das Datum der letzten Änderung sollte mittels 
      opf:metadata/opf:meta[@property = 'dcterms:modified'] angegeben werden, als standardisierter dateTime-String.</diagnostic>
    <diagnostic id="meta-cover-points-nowhere-in-content_de" xml:lang="de">Bilddatei
          '<value-of select="$item/@href"/>' ist in opf:metadata/opf:meta[@name = 'cover'] als Cover ausgewiesen. Allerdings
      scheint die Bilddatei in keiner der HTML-Dateien vorzukommen.</diagnostic>
    <diagnostic id="meta-cover-points-to-non-cover_de" xml:lang="de">Bilddatei '<value-of select="$item/@href"/>' sollte sich in einem Element befinden, dass das Attribut epub:type='cover' enthält. 
     Es kann in Ordnung sein, dasselbe Bild doppelt zu referenzieren, aber es sollte in dem ausgewiesenen Cover-div-Container stehen.</diagnostic>
    <diagnostic id="meta-cover-points-nowhere-in-manifest_de" xml:lang="de">Es gibt keinen Manifest-Eintrag für 
      opf:metadata/opf:meta[@name = 'cover']/@content = '<value-of select="@content"/>'.</diagnostic>
    <diagnostic id="empty-title_de" xml:lang="de">content.opf: metadata/dc:title darf nicht leer sein</diagnostic>
    <diagnostic id="conditional_split_de" xml:lang="de">Bedingter Split vor '<value-of select="substring(normalize-space($doc-elt), 1, 30)"/>…'. (Da das Dokument sonst zu groß werden würde, wurde hier automatisch
     ein Seitenumbruch eingefügt. Falls er an dieser Stelle stört, fügen Sie vorher eine Anweisung zum Splitten ein oder ändern Sie die Einstellungen der Elemente, an denen immer umbrochen wird.)</diagnostic>
    <diagnostic id="no-text-in-chunk_de" xml:lang="de">Split-Datei enthält keinen Text. <!--<xsl:value-of 
      select="if (*) then $elements else 'Enthält nich einmal Tags.'"/>--></diagnostic>
    <diagnostic id="resource-unavailable_de" xml:lang="de">Ressource nicht verfügbar: <a xmlns="http://www.w3.org/1999/xhtml" 
      href="{@checked-href}"><xsl:value-of select="@checked-href"/></a>. 
      Status: <value-of select="@error-status"/><xsl:if test="@error-status = '999'">. Ein Status von 999
        zeigt an, dass die HTTP-Client-Bibliothek die Ressource nicht ansprechen konnte. Das kann daran liegen, dass
        es den Ziel-Server nicht gibt, oder es kann auch ein Kommunikationsfehler des
      HTTP-Clients sein. Die Ressource könnte trotzdem erreichbar sein. Sie müssten den Link im Browser überprüfen.</xsl:if></diagnostic>
    <diagnostic id="bare-text_de" xml:lang="de">Das Container-Element '<value-of select="name()"/>' <value-of select="$atts-string"/> enthält
    ungetaggten Text: <value-of select="$occurrences"/>. Dies kann zwar vom HTML-Schema gestattet sein, sollte aber vermieden
    werden. Es wird hier als Fehler gemeldet, weil es ein typisches Symptom von Auszeichnungs- und/oder Konvertierungsfehlern ist.</diagnostic>
    <diagnostic id="unexpected-validation-input1_de" xml:lang="de">Es existieren mehr als ein HTML-Element im Validierungsinput. Das ist ein Anzeichen für einen Fehlgeschlagenen Split-Prozess.
      need developer support.</diagnostic>
    <diagnostic id="nested-a-element_de" xml:lang="de">Dieses &lt;a&gt;-Element (<value-of 
      select="string-join(for $a in (@* except @srcpath) return concat($a/name(), '=', $a), ', ')"/>) ist in einem anderen &lt;a&gt;-Element enthalten.</diagnostic>
    <diagnostic id="contains-a-element_de" xml:lang="de">Dieses &lt;a&gt;-Element (<value-of 
      select="string-join(for $a in (@* except @srcpath) return concat($a/name(), '=', $a), ', ')"/>) enthält mindestens ein anderes &lt;a&gt;-Element.</diagnostic>
    <diagnostic id="image-type_de" xml:lang="de">Der Medientyp von Bild '<value-of select="@href"/>', '<value-of 
      select="@media-type"/>', entspricht nicht dem regulären Ausdruck '<value-of select="$allowed"/>'.</diagnostic>
    <diagnostic id="dissolved-link_de" xml:lang="de">Der Link auf '<value-of select="$orig-href"/>' konnte nicht aufgelöst werden. 
      Das @href-Attribut wurde entfernt. Inhalt des Links: '<value-of select="."/>'.</diagnostic>
    <diagnostic id="max-dpi_de" xml:lang="de">Das Bild '<value-of select="@href"/>' hat einen dpi-Wert von <value-of select="$dpi"/>.
      Er sollte nicht größer sein als <value-of select="$max"/>.</diagnostic>
    <diagnostic id="min-dpi_de" xml:lang="de">Das Bild '<value-of select="@href"/>' hat einen dpi-Wert von <value-of select="$dpi"/>.
      Er sollte nicht kleiner sein als <value-of select="$min"/>.</diagnostic>
    <diagnostic id="cover-too-narrow_de" xml:lang="de">Das Cover '<value-of select="@href"/>' ist zu schmal: <value-of 
          select="format-number($width, '#0')"/>&#xa0;px. Der Mindestwert ist <value-of select="$min"/></diagnostic>
    <diagnostic id="cover-too-wide_de" xml:lang="de">Das Cover '<value-of select="@href"/>' ist zu breit: <value-of 
          select="format-number($width, '#0')"/>&#xa0;px. Der Höchstwert ist <value-of select="$max"/></diagnostic>
    <diagnostic id="epub-size_de" xml:lang="de">EPUB-Datei '<value-of select="@href"/>' ist recht groß: <value-of 
          select="format-number($size-in-mb, '#0.0')"/>&#xa0;MB. Grenze: <value-of 
          select="format-number($max, '#0.0')"/>&#xa0;MB</diagnostic>
    <diagnostic id="cover-retrieval_de" xml:lang="de">Es gab anscheinend ein Problem beim Anfügen des Coverbildes. Die entspr. Meldung (auf englisch): 
      <xsl:copy-of select="html:p[@class = 'error']/node()"/></diagnostic>
    <diagnostic id="cmyk-image_de" xml:lang="de">Bilddatei '<value-of select="@href"/>' ist CMYK. Nicht alle Lesegeräte stellen diese Bilder dar.</diagnostic>
    <diagnostic id="large-html-file_de" xml:lang="de">HTML-Datei '<value-of select="@href"/>' ist zu groß für manche Lesegeräte: <value-of 
          select="format-number($size-in-kb, '#0')"/>&#xa0;kB. Grenze: <value-of 
          select="format-number($max, '#0')"/>&#xa0;kB<br xmlns="http://www.w3.org/1999/xhtml"/>
     Fügen Sie, wenn möglich, in diese Datei Umbruch-Anweisungen ein oder veranlassen Sie, dass die Zahl der verwendeten Zeichen, die in einer HTML-Datei vorkommen dürfen, verringert wird.
     <br xmlns="http://www.w3.org/1999/xhtml"/><br xmlns="http://www.w3.org/1999/xhtml"/>
     Damit Sie besser abschätzen können, bis wohin die Datei geht, steht hier der Inhalt des letzten Absatzes:
     <br xmlns="http://www.w3.org/1999/xhtml"/>
    	<blockquote xmlns="http://www.w3.org/1999/xhtml">
     		<xsl:value-of select="$element-in-split/(descendant-or-self::*[self::html:p][normalize-space()])[last()]"/>
    	</blockquote>
    </diagnostic>
    <diagnostic id="large-image-file_de" xml:lang="de">Bilddatei '<value-of select="@href"/>' ist recht groß: <value-of 
          select="format-number($size-in-mb, '#0.00')"/>&#xa0;MB</diagnostic>
    <diagnostic id="large-image_de" xml:lang="de">Bild '<value-of select="@href"/>' ist recht groß: <value-of 
      select="$width"/>×<value-of select="$height"/> (<value-of 
          select="format-number($size-in-mpx, '#0.00')"/>&#xa0;Mpx). <xsl:if test="$size-in-mb &lt;= $max-mb">
            Die Dateigröße (<xsl:value-of select="format-number($size-in-mb, '#0.00')"/> MB) ist jedoch ok. </xsl:if></diagnostic>
    <diagnostic id="read-image_de" xml:lang="de">Bilddatei '<value-of select="@href"/>' nicht lesbar:
        <value-of select="c:error"/></diagnostic>
    <diagnostic id="image-analysis-failed_de" xml:lang="de">Bilddatei '<value-of select="@href"/>' nicht lesbar.</diagnostic>
    <diagnostic id="dummy-image_de" xml:lang="de">Eine 1 Byte große Ersatz-Textdatei wurde anstelle von <value-of 
      select="@href"/> eingezogen, weil die Quelldatei nicht gefunden wurde.
    Fehlende Bilder (oder Textdateien anstelle der Bilder) können Folgeprozesse wie kindlegen negativ beeinflussen.</diagnostic>
    <diagnostic id="link-to-file_de" xml:lang="de">Links müssen auf ein Ziel innerhalb der HTML-Quelldatei, auf eine andere
      Datei innerhalb des EPUBs oder auf eine externe Seite verweisen. Dieser zeigt auf: '<value-of select="$normalized"/>'.</diagnostic>
    <diagnostic id="link-to-id_de" xml:lang="de">Die ID '<value-of select="$fragment-id"/>' in der Datei '<value-of 
      select="$normalized"/>' existiert nicht.</diagnostic>
    <diagnostic id="empty-img-alt_de" xml:lang="de">Das alt-Attribute bei Bild '<value-of select="replace(@src, '^.+/', '')"/>' 
      sollte nicht leer sein.</diagnostic>
    <diagnostic id="paragraph-very-long_de" xml:lang="de">
      <span class="srcpath"><xsl:value-of select="for $s in $srcpath return concat($source-dir-uri, $s)"/></span>
      Dieser Absatz beinhaltet mehr als <value-of select="$para-max-string-length"/> Zeichen. 
      Dieser Umstand kann auf manchen Lesegeräten zu längeren Ladezeiten oder zum Absturz führen.
    </diagnostic>
     <diagnostic id="newline-in-chunk_de" xml:lang="de">
      Hier wurde ein unpassender Umbruch verwendet: <xsl:value-of select="descendant::*[matches(string-join(text(),''),$newline-regex)]/text()"/>
    </diagnostic>
    <diagnostic id="table-string-length_de" xml:lang="de">
      Die Zeichenanzahl in der Tabelle liegt bei <value-of select="$str-length"/> Zeichen und übersteigt die Grenze von <value-of select="$max"/> Zeichen.
      Amazon unterstützt keine Tabellen mit mehr als <value-of select="$max"/> Zeichen.
      Mehr Informationen finden Sie in den <a xmlns="http://www.w3.org/1999/xhtml" href="https://kdp.amazon.com/en_US/help/topic/GZ8BAXASXKB5JVML#large_tables" target="_blank">Kindle Publishing Guidelines</a>.
    </diagnostic>
    <diagnostic id="table-cell-count_de" xml:lang="de">
      Die Tabelle enthält <value-of select="$cell-count"/> Zellen und übersteigt die Grenze von <value-of select="$max"/> Zellen.
      Amazon unterstützt keine Tabellen mit mehr als <value-of select="$max"/> Zellen.
      Mehr Informationen finden Sie in den <a xmlns="http://www.w3.org/1999/xhtml" href="https://kdp.amazon.com/en_US/help/topic/GZ8BAXASXKB5JVML#large_tables" target="_blank">Kindle Publishing Guidelines</a>.
    </diagnostic>
  </diagnostics>
  
  <include href="http://transpect.io/xslt-util/isbn/sch/check-isbn_diagnostics.sch.xml"/>
  
</schema>
